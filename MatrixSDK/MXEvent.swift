//
//  MXEvent.swift
//  MatrixSDK
//
//  Created by Gustavo Perdomo on 12/06/16.
//  Copyright Â© 2016 Gustavo Perdomo. All rights reserved.
//

import Foundation
import ObjectMapper

class UInt64Transform: TransformType {
    func transformFromJSON(_ value: Any?) -> UInt64? {
        return UInt64(value as! Int)
    }
    
    func transformToJSON(_ value: UInt64?) -> UInt64? {
        if let value = value {
            return value
        }
        return nil
    }
}

/// MXEvent is the generic model of events received from the home server.
/// It contains all possible keys an event can contain. Thus, all events can be resolved by this model.
class MXEvent: Mappable {
    // MARK: Properties
    
    /// The unique id of the event.
    private(set) var id: String?
    
    /// Contains the ID of the room associated with this event.
    private(set) var roomId: String?
    
    /// Contains the fully-qualified ID of the user who sent this event.
    private(set) var sender: String?
    
    /// The type of event (decrypted, if necessary) type as provided by the homeserver.
    ///
    /// @discussion
    /// If the event is encrypted and the decryption failed (check 'decryptionError' property),
    /// 'type' will remain kMXEventTypeStringRoomEncrypted ("m.room.encrypted").
    private(set) var type: EventType!
    
    /// The event (decrypted, if necessary) content.
    /// The keys in this dictionary depend on the event type.
    /// Check http://matrix.org/docs/spec/client_server/r0.2.0.html#room-events to get a list of content keys per event type.
    ///
    /// @discussion
    /// If the event is encrypted and the decryption failed (check 'decryptionError' property),
    /// 'content' will remain encrypted.
    private(set) var content: Dictionary<String, Any>! = [:]
    
    /// Contains the previous content for this event. If there is no previous content, this key will be missing.
    private(set) var prevContent: Dictionary<String, Any>?
    
    /// Contains the state key for this state event. If there is no state key for this state event, this will be an empty string. The presence of state_key makes this event a state event.
    private(set) var stateKey: String?
    
    /// The timestamp in ms since Epoch generated by the origin homeserver when it receives the event from the client.
    private(set) var originServerTS: UInt64!
    
    /// Information about this event which was not sent by the originating homeserver.
    /// HS sends this data under the 'unsigned' field but it is a reserved keyword. Hence, renaming.
    private(set) var unsigned: Dictionary<String, Any>? = [:]
    
    /// The age of the event in milliseconds.
    /// As home servers clocks may be not synchronised, this relative value may be more accurate.
    /// It is computed by the user's home server each time it sends the event to a client.
    /// Then, the SDK updates it each time the property is read..
    private(set) var age: Int?
    
    /// The `age` value transcoded in a timestamp based on the device clock when the SDK received the event from the home server.
    /// Unlike `age`, this value is static.
    private(set) var ageLocalTS: UInt64?
    
    /// In case of redaction event, this is the id of the event to redact.
    private(set) var redacts: String?
    
    /// In case of redaction, redacted_because contains the event that caused it to be redacted,
    /// which may include a reason
    private(set) var redactedBecause: MXEvent?
    
    /// In case of invite event, inviteRoomState contains a subset of the state of the room at the time of the invite.
    private(set) var inviteRoomState: [MXEvent]?
    
    // MARK: Properties Crypto
    
    /// For encrypted events, the plaintext payload for the event.
    /// This is a small MXEvent instance with typically value for `type` and 'content' fields.
    private(set) var clearEvent: MXEvent?
    
    /// The keys that must have been owned by the sender of this encrypted event.
    ///
    /// @discussion
    /// These don't necessarily have to come from this event itself, but may be
    /// implied by the cryptographic session.
    private var _keysProved: Dictionary<String, String>?
    
    /// The additional keys the sender of this encrypted event claims to possess.
    ///
    /// @discussion
    /// These don't necessarily have to come from this event itself, but may be
    /// implied by the cryptographic session.
    /// For example megolm messages don't claim keys directly, but instead
    /// inherit a claim from the olm message that established the session.
    /// The keys that must have been owned by the sender of this encrypted event.
    private var _keysClaimed: Dictionary<String, String>?
    
    
    /// If any, the error that occured during decryption.
    private(set) var decryptionError: Error?
    
    // MARK: Mappable
    required init?(map: Map) {
        if map.JSON["type"] == nil {
            return nil
        }
    }
    
    func mapping(map: Map) {
        id <- map["event_id"]
        type <- map["type"]
        roomId <- map["room_id"]
        sender <- map["sender"]
        content <- map["content"]
        stateKey <- map["state_key"]
        unsigned <- map["unsigned"]
        
        redacts <- map["redacts"]
        
        originServerTS <- (map["origin_server_ts"], UInt64Transform())
        
        prevContent <- map["prev_content"]
        /// 'prev_content' has been moved under unsigned in some server responses
        if (prevContent == nil)        {
            prevContent <- map["unsigned.prev_content"]
        }
        
        age <- map["age"]
        /// 'age' has been moved under unsigned.
        if (age == nil){
            age <- map["age"]
        }
        
        redactedBecause <- map["redacted_because"]
        /// 'redacted_because' has been moved under unsigned.
        if (redactedBecause == nil) {
            redactedBecause <- map["unsigned.redacted_because"]
        }
        
        inviteRoomState <- map["invite_room_state"]
        
        if type == EventType.presence, sender == nil {
            // Workaround: Presence events provided by the home server do not contain userId in the root of the JSON event object but under its content sub object. Set self.userId in order to follow other events format.
            sender <- map["content.user_id"]
        }
    }
    
    // MARK: Methods
    
    /// Indicates if the event hosts state data.
    ///
    /// - Returns: True if the event hosts state data. False in other case
    func isState() -> Bool {
        return stateKey != nil
    }
    
    /// Indicates if the event has been redacted.
    ///
    /// - Returns: True if the event has been redacted. False in other case
    func isRedactedEvent() -> Bool {
        return redactedBecause != nil
    }
    
    /// Indicates if the event is an emote event.
    ///
    /// - Returns: True if the event is an emote event. False in other case
    func isEmote() -> Bool {
        guard type == EventType.roomMessage, let msgType = content["msgtype"] as? String else {
            return false
        }
        return  MessageType(rawValue: msgType) == MessageType.emote
    }
    
    /// Indicates if the event corresponds to a user profile change
    ///
    /// - Returns: True when the event corresponds to a user profile change.  False in other case
    func isUserProfileChange() -> Bool {
        guard let membership = content["membership"] as? String, let prevMembership = prevContent?["membership"] as? String else {
            return false
        }
        
        return membership == prevMembership
    }
    
    /// This property is relevant only for events with EventType.receipt type
    ///
    /// - Returns: the event IDs for which a read receipt is defined in this event
    func readReceiptEventIds() -> [String] {
        var array = [String]()
        if type == EventType.receipt {
            for (eventId, value) in content {
                if let dict = value as? Dictionary<String, Any>, let _ = dict["m.read"] as? Dictionary<String, Any> {
                    array.append(eventId)
                }
            }
        }
        
        return array
    };
    
    /// This property is relevant only for events with
    ///
    /// - Returns: the fully-qualified IDs of the users who sent read receipts with this event
    func readReceiptSenders() -> [String] {
        var array = [String]()
        if type == EventType.receipt {
            for (_, value) in content {
                if let dict = value as? Dictionary<String, Any>, let readDict = dict["m.read"] as? Dictionary<String, Any> {
                    for (userId, _) in readDict {
                        if(array.index(of: userId) == nil){
                            array.append(userId)
                        }
                    }
                }
            }
        }
        
        return array
    };
    
    
    /// Returns a pruned version of the event, which removes all keys we
    /// don't know about or think could potentially be dodgy.
    /// This is used when we "redact" an event. We want to remove all fields that the user has specified,
    /// but we do want to keep necessary information like type, state_key etc.
    ///
    /// - Returns: The pruned event
    //func prune() -> MXEvent {
    //
    //}
    
    
    /// Comparator to use to order array of events by their originServerTs value.
    /// Arrays are then sorting so that the newest event will be positionned at index 0.
    ///
    /// - Parameter otherEvent: event to compare with self
    /// - Returns: a ComparisonResult value: orderedAscending if otherEvent is newer than self, orderedDescending in other case
    func compareOriginServerTs(with otherEvent: MXEvent) -> ComparisonResult {
        var result: ComparisonResult = .orderedAscending
        if (otherEvent.originServerTS > self.originServerTS)
        {
            result = .orderedDescending
        }
        else if (otherEvent.originServerTS == self.originServerTS)
        {
            result = .orderedSame;
        }
        
        return result
    }
    
    // MARK: - Methods Crypto
    
    /// Indicates if the event is encrypted
    ///
    /// - Returns: True if this event is encrypted, False in other case
    func isEncrypted() -> Bool {
        return type == EventType.roomEncrypted
    }
    
    var senderKey: String? {
        if let key = _keysProved?["curve25519"] {
            return key
        }
        return nil
    }
    
    var keysProved: Dictionary<String,String>? {
        if let _clearEvent = clearEvent {
            return _clearEvent._keysProved
        } else {
            return _keysProved;
        }
    }
    
    var keysClaimed: Dictionary<String,String>? {
        if let _clearEvent = clearEvent {
            return _clearEvent.keysClaimed;
        } else {
            return _keysClaimed;
        }
    }
}
